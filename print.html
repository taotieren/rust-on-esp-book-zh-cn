<!DOCTYPE HTML>
<html lang="zh-CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Rust on ESP Book 简体中文版</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="A comprehensive guide on using the Rust programming language with Espressif SoCs and modules">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 引言</a></li><li class="chapter-item expanded "><a href="overview/index.html"><strong aria-hidden="true">2.</strong> 开发方式总览</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overview/using-the-standard-library.html"><strong aria-hidden="true">2.1.</strong> 使用标准库 (std)</a></li><li class="chapter-item expanded "><a href="overview/using-the-core-library.html"><strong aria-hidden="true">2.2.</strong> 使用核心库 (no_std)</a></li></ol></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">3.</strong> 配置开发环境</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/rust.html"><strong aria-hidden="true">3.1.</strong> Rust 安装</a></li><li class="chapter-item expanded "><a href="installation/riscv.html"><strong aria-hidden="true">3.2.</strong> 仅针对 RISC-V 目标</a></li><li class="chapter-item expanded "><a href="installation/riscv-and-xtensa.html"><strong aria-hidden="true">3.3.</strong> 针对 RISC-V 和 Xtensa 目标</a></li><li class="chapter-item expanded "><a href="installation/std-requirements.html"><strong aria-hidden="true">3.4.</strong> std 开发依赖项</a></li><li class="chapter-item expanded "><a href="installation/using-containers.html"><strong aria-hidden="true">3.5.</strong> 使用容器</a></li></ol></li><li class="chapter-item expanded "><a href="writing-your-own-application/index.html"><strong aria-hidden="true">4.</strong> 编写自己的应用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/index.html"><strong aria-hidden="true">4.1.</strong> 从模板生成项目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/esp-template.html"><strong aria-hidden="true">4.1.1.</strong> esp-template 简介</a></li><li class="chapter-item expanded "><a href="writing-your-own-application/generate-project/esp-idf-template.html"><strong aria-hidden="true">4.1.2.</strong> esp-idf-template 简介</a></li></ol></li><li class="chapter-item expanded "><a href="writing-your-own-application/nostd.html"><strong aria-hidden="true">4.2.</strong> 编写 no_std 应用</a></li><li class="chapter-item expanded "><a href="writing-your-own-application/std.html"><strong aria-hidden="true">4.3.</strong> 编写 std 应用</a></li></ol></li><li class="chapter-item expanded "><a href="tooling/index.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/visual-studio-code.html"><strong aria-hidden="true">5.1.</strong> Visual Studio Code</a></li><li class="chapter-item expanded "><a href="tooling/espflash.html"><strong aria-hidden="true">5.2.</strong> espflash</a></li><li class="chapter-item expanded "><a href="tooling/debugging/index.html"><strong aria-hidden="true">5.3.</strong> 调试</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/debugging/probe-rs.html"><strong aria-hidden="true">5.3.1.</strong> probe-rs</a></li><li class="chapter-item expanded "><a href="tooling/debugging/openocd.html"><strong aria-hidden="true">5.3.2.</strong> OpenOCD</a></li><li class="chapter-item expanded "><a href="tooling/debugging/vscode.html"><strong aria-hidden="true">5.3.3.</strong> 在 Visual Studio Code 中调试</a></li></ol></li><li class="chapter-item expanded "><a href="tooling/simulating/index.html"><strong aria-hidden="true">5.4.</strong> 仿真</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tooling/simulating/wokwi.html"><strong aria-hidden="true">5.4.1.</strong> Wokwi</a></li><li class="chapter-item expanded "><a href="tooling/simulating/qemu.html"><strong aria-hidden="true">5.4.2.</strong> QEMU</a></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="misc/troubleshooting.html">附录 A: Troubleshooting</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust on ESP Book 简体中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Narukara/rust-on-esp-book-zh-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p style="text-align:center;"><img src="./assets/esp-logo-black.svg" width="50%"></p>
<h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<p>本书的目的在于提供一个将 <a href="https://www.rust-lang.org/">Rust 编程语言</a>用于<a href="https://espressif.com/">乐鑫（Espressif）</a>设备的全面指南。</p>
<p>Rust 对这些设备的支持仍在不断改进中，并且进展迅速。因此，本文档的某些部分可能已经过时，或者在多次阅读之间发生了重大变化。</p>
<p>对于与 Rust on ESP 相关的工具和库，请查看 GitHub 上的 <a href="https://github.com/esp-rs/">esp-rs 组织</a>。该组织由乐鑫的员工以及社区成员共同管理。</p>
<h2 id="这本书适合谁"><a class="header" href="#这本书适合谁">这本书适合谁</a></h2>
<p>本书适用于具有一定 Rust 经验，并且对嵌入式开发和电子相关知识有基础了解的人群。对于没有相关经验的读者，我们建议先阅读<a href="introduction.html#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6">前提条件</a>和<a href="introduction.html#%E8%B5%84%E6%BA%90">资源</a>部分，以快速掌握相关知识。</p>
<h3 id="前提条件"><a class="header" href="#前提条件">前提条件</a></h3>
<ul>
<li>你能够轻松使用 Rust 编程语言，并且在桌面环境下编写和运行过应用程序。</li>
<li>你应该熟悉 <a href="https://doc.rust-lang.org/edition-guide/rust-2021/index.html">Rust 2021 版</a>的术语，因为本书面向的是 Rust 2021 版。</li>
<li>你能够轻松使用其他语言（如 C 或 C++）开发嵌入式系统，并熟悉以下概念：
<ul>
<li>交叉编译</li>
<li>常见数字接口，如 <code>UART</code>、<code>SPI</code>、<code>I2C</code> 等</li>
<li>内存映射外设</li>
<li>中断</li>
</ul>
</li>
</ul>
<h3 id="资源"><a class="header" href="#资源">资源</a></h3>
<p>如果你对上面提到的任何内容不够熟悉，或者只是想要关于书中特定主题的更多信息，以下资源可能会很有帮助：</p>
<div class="table-wrapper"><table><thead><tr><th>资源</th><th>描述</th></tr></thead><tbody>
<tr><td><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></td><td>如果你不熟悉 Rust，我们建议你先阅读这本书。</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/book/index.html">The Embedded Rust Book</a></td><td>这里包含由 Rust 嵌入式工作组提供的其他资源。</td></tr>
<tr><td><a href="https://docs.rust-embedded.org/embedonomicon/">The Embedonomicon</a></td><td>在使用 Rust 进行嵌入式编程时的细节。</td></tr>
<tr><td><a href="https://esp-rs.github.io/std-training/">Embedded Rust on Espressif</a></td><td>与 <a href="https://ferrous-systems.com/">Ferrous Systems</a> 合作编写的培训材料。</td></tr>
</tbody></table>
</div>
<h2 id="翻译"><a class="header" href="#翻译">翻译</a></h2>
<p>本书已由慷慨的志愿者参与翻译。如果你希望在此处列出你的译本，请（向英文原版仓库）提交 PR。</p>
<ul>
<li><a href="https://esp-rs.github.io/book/">English</a> （<a href="https://github.com/esp-rs/book">仓库</a>）</li>
</ul>
<h2 id="如何使用这本书"><a class="header" href="#如何使用这本书">如何使用这本书</a></h2>
<p>本书假设你按顺序从头到尾阅读。在没有前面章节的背景知识时，后面章节涵盖的内容可能会不太容易理解。</p>
<h2 id="为本书做出贡献"><a class="header" href="#为本书做出贡献">为本书做出贡献</a></h2>
<p>本书的工作是在<a href="https://github.com/esp-rs/book">此代码仓库</a>中进行协调的。</p>
<p>如果你在按照书中的说明进行操作时遇到问题，或者发现书中的某些部分不够清晰，那么这就是一个 bug。请在本书的<a href="https://github.com/esp-rs/book/issues/"> issue 追踪器</a>中报告该问题。</p>
<p>欢迎提交修复 typo 和添加新内容的 Pull Request。</p>
<h2 id="重用本材料"><a class="header" href="#重用本材料">重用本材料</a></h2>
<p>本书根据以下许可分发：</p>
<ul>
<li>本书中包含的示例代码和独立的 Cargo 项目均根据 <a href="https://opensource.org/licenses/MIT">MIT 许可证</a>和 <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 许可证 v2.0</a> 的条款获得许可。</li>
<li>本书中包含的文字、图片和图表均根据 Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> 许可条款获得许可。</li>
</ul>
<p>总而言之，如果要在你的作品中使用本书的文本或图像，你需要：</p>
<ul>
<li>给予适当的认可（例如，在幻灯片上提及这本书，并提供相关页面的链接）</li>
<li>提供指向 <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA v4.0</a> 许可证的链接</li>
<li>指出你是否以任何方式更改了材料，并使这些更改在相同的许可证下可用</li>
</ul>
<p>如果你觉得这本书有用，请告诉我们！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="开发方式总览"><a class="header" href="#开发方式总览">开发方式总览</a></h1>
<p>在乐鑫芯片上使用 Rust 开发，有以下两种方式：</p>
<ul>
<li>使用 <code>std</code> 库，即标准库。</li>
<li>使用 <code>core</code> 库（<code>no_std</code>），即裸机开发。</li>
</ul>
<p>两种方式各有各的优缺点，因此需要根据项目需求选取。本章包含对两种开发方式的概述。</p>
<ul>
<li><a href="overview/./using-the-standard-library.html">使用标准库 (<code>std</code>)</a></li>
<li><a href="overview/./using-the-core-library.html">使用核心库 (<code>no_std</code>)</a></li>
</ul>
<p>另请参阅 <a href="https://docs.rust-embedded.org/book/intro/no-std.html#a-no_std-rust-environment">The Embedded Rust Book</a> 中对不同运行时的比较。</p>
<p>GitHub 上的 <a href="https://github.com/esp-rs/">esp-rs 组织</a> 有多个仓库，与在乐鑫芯片上运行 Rust 相关。大多数所需的 crate 的源代码都托管在这里。</p>
<h2 id="仓库命名约定"><a class="header" href="#仓库命名约定">仓库命名约定</a></h2>
<p>在 <a href="https://github.com/esp-rs/">esp-rs 组织</a>中，我们使用以下命名约定：</p>
<ul>
<li>以 <code>esp-</code> 开头的仓库关注 <code>no_std</code> 方式。例如 <code>esp-hal</code>
<ul>
<li><code>no_std</code> 在裸机上运行，因此 <code>esp-</code> 代表乐鑫芯片</li>
</ul>
</li>
<li>以 <code>esp-idf-</code> 开头的仓库关注 <code>std</code> 方式。例如 <code>esp-idf-hal</code>
<ul>
<li><code>std</code> 在裸机之上，还需要一个<a href="https://github.com/espressif/esp-idf">额外的封装层</a>，即 <code>esp-idf-</code></li>
</ul>
</li>
</ul>
<h2 id="对乐鑫产品的支持"><a class="header" href="#对乐鑫产品的支持">对乐鑫产品的支持</a></h2>
<blockquote>
<p>⚠️ <strong>注意</strong>：</p>
<ul>
<li>✅ - 此功能已实现或支持</li>
<li>⏳ - 此功能正在开发</li>
<li>❌ - 不支持此功能</li>
</ul>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>芯片</th><th style="text-align: center"><code>std</code></th><th style="text-align: center"><code>no_std</code></th></tr></thead><tbody>
<tr><td>ESP32</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C6</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-H2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP8266</td><td style="text-align: center">❌</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ <strong>注意</strong>： ESP8266 系列不在本书的讨论范围内。Rust 对
ESP8266 系列的支持有限，且并未得到乐鑫的官方支持。</p>
</blockquote>
<p>在一定情况下支持的产品，在本书中称为“支持的乐鑫产品”。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用标准库std"><a class="header" href="#使用标准库std">使用标准库（<code>std</code>）</a></h1>
<p>乐鑫提供了一个基于 C 的开发框架，称为 <a href="https://github.com/espressif/esp-idf">ESP-IDF</a>。它支持（或将会支持）所有名称以 ESP32 开头的乐鑫芯片。注意，该框架 <em>不</em> 支持 ESP8266。</p>
<p>ESP-IDF 提供了一个功能强大的 <a href="https://sourceware.org/newlib/">newlib</a> 环境，足以在其上构建 Rust 标准库（<code>std</code>）。这就是在乐鑫设备上启用 <code>std</code> 支持的方法。</p>
<h2 id="当前支持情况"><a class="header" href="#当前支持情况">当前支持情况</a></h2>
<p>只要是 ESP-IDF 框架支持的乐鑫产品，就支持 Rust <code>std</code> 开发。有关 ESP-IDF 的不同版本，以及乐鑫芯片支持的详细信息，请参阅<a href="https://github.com/espressif/esp-idf#esp-idf-release-and-soc-compatibility/">此表格</a>。</p>
<p>使用 <code>std</code> 时，可以访问 <a href="https://github.com/espressif/esp-idf">ESP-IDF</a> 中存在的许多功能，包括线程、互斥锁和其他同步原语、集合、随机数生成、套接字等。</p>
<h3 id="esp-rs-相关的-crate"><a class="header" href="#esp-rs-相关的-crate"><code>esp-rs</code> 相关的 Crate</a></h3>
<div class="table-wrapper"><table><thead><tr><th>仓库</th><th>描述</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/embedded-svc"><code>embedded-svc</code></a></td><td>嵌入式服务的抽象 trait（<code>WiFi</code>、<code>Network</code>、<code>Httpd</code>、<code>Logging</code>）。</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-svc"><code>esp-idf-svc</code></a></td><td>用 <code>esp-idf</code> 驱动实现的 <a href="https://github.com/esp-rs/embedded-svc">embedded-svc</a>。</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-hal"><code>esp-idf-hal</code></a></td><td>用 <code>esp-idf</code> 框架实现的 <code>embedded-hal</code> 和其他 trait。</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-idf-sys"><code>esp-idf-sys</code></a></td><td><code>esp-idf</code> 开发框架的 Rust 绑定（binding）。提供了对驱动、Wi-Fi 和其他功能的原始（<code>unsafe</code>）访问。</td></tr>
</tbody></table>
</div>
<p>上述 crate 的相互依赖关系如下图所示。</p>
<pre class="mermaid">graph TD;
    esp-idf-hal --&gt; esp-idf-sys &amp; embedded-svc
    esp-idf-svc --&gt; esp-idf-sys &amp; esp-idf-hal &amp; embedded-svc
</pre>
<h3 id="何时适合使用标准库std"><a class="header" href="#何时适合使用标准库std">何时适合使用标准库（<code>std</code>）</a></h3>
<ul>
<li>丰富的功能：如果你的嵌入式系统需要大量功能，例如支持网络协议、文件 I/O 或复杂的数据结构，使用宿主环境（hosted-environment）会是一个较好的方法。因为 <code>std</code> 库提供了丰富的功能，便于构建复杂的应用程序。</li>
<li>可移植性：<code>std</code> crate 提供了一组标准化的 API，可以跨不同平台和架构使用，使你能够更轻松地编写可移植和可重用的代码。</li>
<li>快速开发：<code>std</code> crate 提供了一组丰富的功能，可用于快速高效地构建应用程序，而无需过多担心底层细节。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用核心库no_std"><a class="header" href="#使用核心库no_std">使用核心库（<code>no_std</code>）</a></h1>
<p>嵌入式 Rust 开发者可能更熟悉使用 <code>no_std</code>。这种开发方式不使用 <code>std</code>（Rust <a href="https://doc.rust-lang.org/std/index.html"><code>标准</code></a>库），而使用它的一个子集，即<a href="https://doc.rust-lang.org/core/index.html"><code>核心</code></a>库。<a href="https://docs.rust-embedded.org/">The Embedded Rust Book</a> 中的<a href="https://docs.rust-embedded.org/book/intro/no-std.html">一章</a>介绍了相关的知识。</p>
<p>需要注意的是，<code>no_std</code> 使用 Rust <code>核心</code>库。由于该库是 Rust <code>标准</code>库的一部分，因此 <code>no_std</code> crate 可以在 <code>std</code> 环境中编译。反之则不然：<code>std</code> crate 无法在 <code>no_std</code> 环境中编译。在决定选择哪个库时，请记住这一点。</p>
<h2 id="当前支持情况-1"><a class="header" href="#当前支持情况-1">当前支持情况</a></h2>
<p>下表展示了目前各类乐鑫产品对 <code>no_std</code> 的支持情况。</p>
<div class="table-wrapper"><table><thead><tr><th></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-hal" title="Hardware abstraction layer">HAL</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-wifi" title="Wi-Fi, BLE and ESP-NOW support">Wi-Fi/BLE/ESP-NOW</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-backtrace" title="Exception and panic handlers">Backtrace</a></th><th style="text-align: center"><a href="https://github.com/esp-rs/esp-storage" title="Embedded-storage traits to access unencrypted flash memory">Storage</a></th></tr></thead><tbody>
<tr><td>ESP32</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-C6</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S2</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-S3</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td>ESP32-H2</td><td style="text-align: center">✅</td><td style="text-align: center">⏳</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ <strong>注意</strong>:</p>
<ul>
<li>Wi-Fi/BLE/ESP-NOW 一列中的 ✅ 表示此目标支持其中至少一种功能。详细情况参见 esp-wifi 仓库中的 <a href="https://github.com/esp-rs/esp-wifi#current-support">Current support</a> 表格。</li>
<li><a href="https://github.com/esp-rs/esp8266-hal" title="ESP8266 Hardware abstraction layer">ESP8266 HAL</a> 处于维护状态，后续不会对此芯片做进一步开发。</li>
</ul>
</blockquote>
<h3 id="esp-rs-相关的-crate-1"><a class="header" href="#esp-rs-相关的-crate-1"><code>esp-rs</code> 相关的 Crate</a></h3>
<div class="table-wrapper"><table><thead><tr><th>仓库</th><th>描述</th></tr></thead><tbody>
<tr><td><a href="https://github.com/esp-rs/esp-hal" title="Hardware abstraction layer"><code>esp-hal</code></a></td><td>硬件抽象层</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-pacs" title="Peripheral access crates"><code>esp-pacs</code></a></td><td>外设访问 crate（PAC）</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-wifi" title="Wi-Fi, BLE and ESP-NOW support"><code>esp-wifi</code></a></td><td>Wi-Fi、BLE 和 ESP-NOW 支持</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-alloc" title="Simple heap allocator"><code>esp-alloc</code></a></td><td>简单的堆分配器</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-println" title="print!, println!"><code>esp-println</code></a></td><td><code>print!</code> 和 <code>println!</code></td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-backtrace" title="Exception and panic handlers"><code>esp-backtrace</code></a></td><td>异常和恐慌（panic）处理程序</td></tr>
<tr><td><a href="https://github.com/esp-rs/esp-storage" title="Embedded-storage traits to access unencrypted flash memory"><code>esp-storage</code></a></td><td>用于访问未加密 flash 的嵌入式存储 trait</td></tr>
</tbody></table>
</div>
<h3 id="何时适合使用核心库no_std"><a class="header" href="#何时适合使用核心库no_std">何时适合使用核心库（<code>no_std</code>）</a></h3>
<ul>
<li>内存占用小：如果你的嵌入式系统资源有限，并且需要较小的内存占用，采用裸机开发方式可能较好。因为引入 <code>std</code> 会极大增加最终生成的二进制程序尺寸和编译时间。</li>
<li>直接的硬件控制：如果你的嵌入式系统需要对硬件进行更直接的控制，例如底层设备驱动或访问专用的硬件功能，采用裸机开发可能较好。因为 <code>std</code> 引入了额外的抽象层，使得直接与硬件交互变得更加困难。</li>
<li>实时性约束或时间关键型应用：如果你的嵌入式系统需要较强的实时性，或较低的响应延迟时间。因为 <code>std</code> 可能会引入不可预测的延迟和开销，从而影响实时性。</li>
<li>自定义需求：裸机开发允许对应用程序的行为进行更多自定义和细粒度的控制，这在专用或非标准环境中非常有用。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置开发环境"><a class="header" href="#配置开发环境">配置开发环境</a></h1>
<p>目前，乐鑫的 SoC 基于两种不同的架构：<code>RISC-V</code> 和 <code>Xtensa</code>。两种架构都支持 <code>std</code> 和 <code>no_std</code> 开发方式。</p>
<p>为了配置开发环境，需要执行以下步骤：</p>
<ol>
<li><a href="installation/./rust.html">安装 Rust</a></li>
<li>根据目标架构，安装相应的依赖项
<ul>
<li><a href="installation/./riscv.html">仅针对 <code>RISC-V</code> 目标</a></li>
<li><a href="installation/./riscv-and-xtensa.html">针对 <code>RISC-V</code> 和 <code>Xtensa</code> 目标</a></li>
</ul>
</li>
</ol>
<p>不论是哪种目标架构，对于 <code>std</code> 开发，还需要安装 <a href="installation/./std-requirements.html"><code>std</code> 开发依赖项</a>。</p>
<p>另外，还可以选择在<a href="installation/./using-containers.html">容器</a>中托管开发环境。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-安装"><a class="header" href="#rust-安装">Rust 安装</a></h1>
<p>确保你已经安装了 <a href="https://www.rust-lang.org/">Rust</a>。如果没有，请参阅 <a href="https://rustup.rs/">rustup</a> 网站上的说明。</p>
<blockquote>
<p>🚨 <strong>警告</strong>：使用基于 Unix 的系统时，通过系统的包管理器（例如 <code>brew</code>、<code>apt</code>、<code>dnf</code> 等）安装 Rust 可能导致多种兼容性问题，因此最好还是使用 <a href="https://rustup.rs/">rustup</a>。</p>
</blockquote>
<p>使用 Windows 时，请确保你已安装下面列出的 ABI 之一。有关更多详细信息，请参阅 rustup book 中的 <a href="https://rust-lang.github.io/rustup/installation/windows.html">Windows</a> 章节。</p>
<ul>
<li><strong>MSVC</strong>：推荐的 ABI，包含在 <code>rustup</code> 的默认依赖项列表中。使用此 ABI 可以与 Visual Studio 生成的软件实现互操作。</li>
<li><strong>GNU</strong>：GCC 工具链使用的 ABI。你可以自行安装它，以便与使用 MinGW/MSYS2 工具链构建的软件实现互操作。</li>
</ul>
<p>另请参阅<a href="https://rust-lang.github.io/rustup/installation/other.html">其他安装方案</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仅针对-risc-v-目标"><a class="header" href="#仅针对-risc-v-目标">仅针对 <code>RISC-V</code> 目标</a></h1>
<p>要为基于 <code>RISC-V</code> 架构的乐鑫芯片构建 Rust 应用程序，请执行以下步骤：</p>
<ol>
<li>
<p>安装 <a href="https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust"><code>nightly</code></a> 工具链以及 <code>rust-src</code> <a href="https://rust-lang.github.io/rustup/concepts/components.html">组件</a>：</p>
<pre><code class="language-shell">rustup toolchain install nightly --component rust-src
</code></pre>
</li>
<li>
<p>设置目标：</p>
<ul>
<li>
<p>对于 <code>no_std</code>（裸机）应用，运行：</p>
<pre><code class="language-shell">rustup target add riscv32imc-unknown-none-elf # 针对 ESP32-C2 和 ESP32-C3
rustup target add riscv32imac-unknown-none-elf # 针对 ESP32-C6 和 ESP32-H2
</code></pre>
<p>这些目标目前属于 <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-2">Tier 2</a>。注意 Rust 中不同的 <code>riscv32</code> 目标包含了不同的 <a href="https://en.wikichip.org/wiki/risc-v/standard_extensions"><code>RISC-V</code> 扩展</a>。</p>
</li>
<li>
<p>对于 <code>std</code> 应用：</p>
<p>由于这些目标目前属于 <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-3">Tier 3</a>，所以不存在通过 <code>rustup</code> 分发的预构建对象，并且与 <code>no_std</code> 目标不同，<strong>不需要安装任何东西</strong>。请参阅 rustc book 一书的 <a href="https://doc.rust-lang.org/nightly/rustc/platform-support/esp-idf.html">*-esp-idf</a> 章节以找到适配具体设备的目标。</p>
<ul>
<li><code>riscv32imc-esp-espidf</code> 针对不支持原子指令（A）扩展的 SoC，例如 ESP32-C2 和 ESP32-C3</li>
<li><code>riscv32imac-esp-espidf</code> 针对支持原子指令（A）扩展的 SoC，例如 ESP32-C6、ESP32-H2 和 ESP32-P4</li>
</ul>
</li>
</ul>
</li>
<li>
<p>为了构建 <code>std</code> 项目，还需要安装：</p>
<ul>
<li><a href="https://llvm.org/"><code>LLVM</code></a> 编译器基础设施</li>
<li>其他 <a href="installation/./std-requirements.html"><code>std</code> 开发依赖项</a></li>
<li>在项目的 <code>.cargo/config.toml</code> 文件中添加 Cargo 的不稳定<a href="https://doc.rust-lang.org/cargo/reference/unstable.html">特性</a> <code>-Z build-std</code>。我们的<a href="installation/../writing-your-own-application/generate-project/index.html">模板项目</a>（将在后面章节讨论）已经包含了这一项。</li>
</ul>
</li>
</ol>
<p>现在你应该就能在乐鑫的 <code>RISC-V</code> 芯片上构建和运行一个项目了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="针对-risc-v-和-xtensa-目标"><a class="header" href="#针对-risc-v-和-xtensa-目标">针对 <code>RISC-V</code> 和 <code>Xtensa</code> 目标</a></h1>
<p>为 <code>Xtensa</code> 和 <code>RISC-V</code> 架构开发 Rust 应用程序，需要安装和维护一些组件。<a href="https://github.com/esp-rs/espup"><code>espup</code></a> 是一款能够简化这一过程的工具。</p>
<h3 id="1-安装-espup"><a class="header" href="#1-安装-espup">1. 安装 <code>espup</code></a></h3>
<p>要安装 <code>espup</code>，执行：</p>
<pre><code class="language-shell">cargo install espup
</code></pre>
<p>也可以直接下载预编译好的<a href="https://github.com/esp-rs/espup/releases">发行二进制文件</a>或使用<a href="https://github.com/cargo-bins/cargo-binstall"><code>cargo-binstall</code></a>。</p>
<h3 id="2-安装必要的工具链"><a class="header" href="#2-安装必要的工具链">2. 安装必要的工具链</a></h3>
<p>要为所有支持 Rust 开发的乐鑫目标，安装所有必要的工具，执行：</p>
<pre><code class="language-shell">espup install
</code></pre>
<blockquote>
<p>⚠️ <strong>注意</strong>：<code>std</code> 应用需要安装一些额外的软件，参见 <a href="installation/./std-requirements.html"><code>std</code> 开发依赖项</a></p>
</blockquote>
<h3 id="3-配置环境变量"><a class="header" href="#3-配置环境变量">3. 配置环境变量</a></h3>
<p><code>espup</code> 会创建一个 export 文件，其中包含构建项目所需的一些环境变量。</p>
<p>在 Windows 系统上（<code>%USERPROFILE%\export-esp.ps1</code>）</p>
<ul>
<li>对于 Windows 用户，<strong>不需要</strong> 执行这个文件。这个文件只是用来展示哪些环境变量被修改了的。</li>
</ul>
<p>在基于 Unix 的系统上（<code>$HOME/export-esp.sh</code>），有几种不同的方法来 source 这个文件：</p>
<ul>
<li>
<p>在每个终端里 source 这个文件：</p>
<ol>
<li>source 这个 export 文件： <code>. $HOME/export-esp.sh</code></li>
</ol>
<p>这种方法需要在每个新的 shell 里运行这个命令。</p>
</li>
<li>
<p>创建用于执行 <code>export-esp.sh</code> 的别名（alias）：</p>
<ol>
<li>将以下命令复制粘贴到 shell 的配置文件中（<code>.profile</code>、<code>.bashrc</code>、<code>.zprofile</code> 等）：<code>alias get_esprs='. $HOME/export-esp.sh'</code></li>
<li>通过重启终端，或执行 <code>source [配置文件的路径]</code>，例如 <code>source ~/.bashrc</code>，来刷新配置。</li>
</ol>
<p>这种方法需要在每个新的 shell 里运行别名（alias）。</p>
</li>
<li>
<p>直接将环境变量添加到 shell 配置文件中：</p>
<ol>
<li>把 <code>$HOME/export-esp.sh</code> 的内容添加到 shell 的配置文件中：<code>cat $HOME/export-esp.sh &gt;&gt; [配置文件的路径]</code>，例如 <code>cat $HOME/export-esp.sh &gt;&gt; ~/.bashrc</code>。</li>
<li>通过重启终端，或执行 <code>source [配置文件的路径]</code>，例如 <code>source ~/.bashrc</code>，来刷新配置。</li>
</ol>
<p>这种方法 <strong>不需要</strong> 任何 source。<code>export-esp.sh</code> 脚本会在每个 shell 里自动 source。</p>
</li>
</ul>
<h3 id="espup-安装了什么"><a class="header" href="#espup-安装了什么"><code>espup</code> 安装了什么</a></h3>
<p>为了启用对乐鑫目标的支持，<code>espup</code> 安装了以下工具：</p>
<ul>
<li>乐鑫 Rust 分支，支持乐鑫目标</li>
<li><code>nightly</code> 工具链，支持 <code>RISC-V</code> 目标</li>
<li><code>LLVM</code> <a href="https://github.com/espressif/llvm-project">分支</a>，支持 <code>Xtensa</code> 目标</li>
<li><a href="https://github.com/espressif/crosstool-NG/">GCC 工具链</a>，用于链接最终的二进制文件</li>
</ul>
<p>分支编译器能与标准 Rust 编译器共存，允许在一个系统上同时安装两者。可以用任意一种 <a href="https://rust-lang.github.io/rustup/overrides.html">override 方法</a>来调用分支编译器。</p>
<blockquote>
<p>⚠️ <strong>注意</strong>：我们正在努力将分支的代码合并入上游仓库</p>
<ol>
<li><code>LLVM</code> 分支中的修改。合并正在进行中，详见这个<a href="https://github.com/espressif/llvm-project/issues/4">跟踪 issue</a>。</li>
<li>Rust 编译器分支。如果 <code>LLVM</code> 中的修改被接受，我们将继续推进 Rust 编译器的修改。</li>
</ol>
</blockquote>
<p>如果你遇到了错误，请查看 <a href="installation/../misc/troubleshooting.html">Troubleshooting</a> 章节。</p>
<h3 id="xtensa-目标的其他安装方法"><a class="header" href="#xtensa-目标的其他安装方法"><code>Xtensa</code> 目标的其他安装方法</a></h3>
<ul>
<li>使用 <a href="https://github.com/esp-rs/rust-build#download-installer-in-bash"><code>rust-build</code></a> 安装脚本。这是过去推荐的方式，但现在安装脚本已”功能冻结“，所有新功能将仅包含在 <code>espup</code> 中。请参阅仓库 README 文件以获取说明。</li>
<li>从源代码构建具有 <code>Xtensa</code> 支持的 Rust 编译器。此过程的运算成本很高，可能需要一个或多个小时才能完成，具体取决于系统配置。除非有重大理由要求采用这种方法，否则不建议这样做。这是从源代码构建它的仓库：<a href="https://github.com/esp-rs/rust"><code>esp-rs/rust</code> 仓库</a>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="std-开发依赖项"><a class="header" href="#std-开发依赖项"><code>std</code> 开发依赖项</a></h1>
<p>不论是哪种目标架构，对于 <a href="installation/../overview/using-the-standard-library.html"><code>std</code></a> 应用开发，还需要安装以下工具：</p>
<ul>
<li><a href="https://www.python.org/downloads/"><code>python</code></a>：ESP-IDF 的要求</li>
<li><a href="https://git-scm.com/downloads"><code>git</code></a>：ESP-IDF 的要求</li>
<li><a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a> 二进制项 crate：一个将链接参数转发给实际链接器的工具，实际链接器本身也是通过参数指定的。执行以下命令来安装：
<pre><code class="language-shell">cargo install ldproxy
</code></pre>
</li>
</ul>
<p><code>std</code> 运行时将 <a href="https://github.com/espressif/esp-idf">ESP-IDF</a>（Espressif IoT Development Framework）作为宿主环境，不过用户不需要安装它。<a href="https://github.com/esp-rs/esp-idf-sys">esp-idf-sys</a> 会自动下载安装 ESP-IDF，这是一个所有 <code>std</code> 项目都需要使用的 crate。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用容器"><a class="header" href="#使用容器">使用容器</a></h1>
<p>你可以将开发环境托管在容器内，而不是直接安装在本机上。乐鑫提供了 <a href="https://hub.docker.com/r/espressif/idf-rust/tags"><code>idf-rust</code></a> 镜像，支持 <code>RISC-V</code> 和 <code>Xtensa</code> 目标架构，并支持 <code>std</code> 和 <code>no_std</code> 开发。</p>
<p>有许多针对 <code>linux/arm64</code> 或 <code>linux/amd64</code> 平台的 tag。</p>
<p>对于每个 Rust 版本，我们都使用以下命名约定来生成 tag：</p>
<ul>
<li><code>&lt;芯片&gt;_&lt;rust工具链版本&gt;</code>
<ul>
<li>例如，<code>esp32_1.64.0.0</code> 包含用于在 <code>ESP32</code> 上开发 <code>std</code> 和 <code>no_std</code> 应用的环境，使用的是 <code>1.64.0.0</code> <code>Xtensa</code> Rust 工具链。</li>
</ul>
</li>
</ul>
<p>有几种特殊情况：</p>
<ul>
<li><code>&lt;芯片&gt;</code> 可以是 <code>all</code>，表示兼容所有乐鑫目标</li>
<li><code>&lt;rust工具链版本&gt;</code> 可以是 <code>latest</code>，表示 <code>Xtensa</code> Rust 工具链的最新版本</li>
</ul>
<p>根据你使用的操作系统，你可以选择任意一种容器运行时，例如 <a href="https://www.docker.com/">Docker</a>、<a href="https://podman.io/">Podman</a> 或 <a href="https://github.com/lima-vm/lima">Lima</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写自己的应用"><a class="header" href="#编写自己的应用">编写自己的应用</a></h1>
<p>安装了适当的 Rust 编译器和工具链后，就可以开始创建自己的应用了。</p>
<p>可以采用以下方法来编写应用：</p>
<ul>
<li>(<strong>强烈推荐</strong>) 从现成的模板生成项目：可以提供一个配置好的项目，节省时间，避免出错。</li>
<li>借助 Cargo 从零开始构建：需要更多专业知识，因为你需要配置项目的多个部分。
<blockquote>
<p>⚠️ <strong>注意</strong>：用 Cargo 自行构建项目没有任何优势。在这里提及，只是因为这是生成 Rust 项目的常规方法。</p>
</blockquote>
</li>
</ul>
<p>本章不会介绍如何使用 <code>cargo</code> 从零开始​​创建项目，只会关注如何从模板生成项目。</p>
<p>本章使用到的工具将在下一章“<a href="writing-your-own-application/../tooling/index.html">工具</a>”中详细介绍，需要时请随时参考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="从模板生成项目"><a class="header" href="#从模板生成项目">从模板生成项目</a></h1>
<p>我们目前维护了两个模板仓库：</p>
<ul>
<li><a href="https://github.com/esp-rs/esp-template"><code>esp-template</code></a> - <code>no_std</code> 模板。</li>
<li><a href="https://github.com/esp-rs/esp-idf-template"><code>esp-idf-template</code></a> - <code>std</code> 模板。</li>
</ul>
<p>这两个模板都是基于 <a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a>，这是一个用于按照现成模板创建新项目的工具。这里的 <a href="https://github.com/esp-rs/esp-idf-template"><code>esp-idf-template</code></a> 和 <a href="https://github.com/esp-rs/esp-template"><code>esp-template</code></a> 可用于生成应用程序，附带所有必需的配置和依赖项。</p>
<ol>
<li>
<p>安装 <code>cargo generate</code>：</p>
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
</li>
<li>
<p>基于以上模板之一生成项目：</p>
<ul>
<li><code>esp-template</code>：
<pre><code class="language-shell">cargo generate esp-rs/esp-template
</code></pre>
关于模板项目的更多信息，请参阅 <a href="writing-your-own-application/generate-project/./esp-template.html"><code>esp-template</code> 简介</a>。</li>
<li><code>esp-idf-template</code>：
<pre><code class="language-shell">cargo generate esp-rs/esp-idf-template cargo
</code></pre>
关于模板项目的更多信息，请参阅 <a href="writing-your-own-application/generate-project/./esp-idf-template.html"><code>esp-idf-template</code> 简介</a>。</li>
</ul>
<p>调用 <code>cargo generate</code> 子命令时，它会询问几个关于应用程序目标的问题。完成这些问题后，就会生成一个配置好的项目，可以直接构建。</p>
</li>
<li>
<p>构建/运行生成的项目：</p>
<ul>
<li>用 <code>cargo build</code> 编译项目（自动使用合适的工具链和目标）。</li>
<li>用 <code>cargo run</code> 编译项目、向目标设备烧写程序、并开启一个串口监视器。</li>
</ul>
</li>
</ol>
<h2 id="在模板中使用开发容器dev-container"><a class="header" href="#在模板中使用开发容器dev-container">在模板中使用开发容器（Dev Container）</a></h2>
<p>两个模板仓库都带有开发容器支持，详见模板 README 的 <a href="https://github.com/esp-rs/esp-template/tree/main/docs#dev-containers">Dev Containers</a> 章节。</p>
<p>开发容器使用 <a href="https://hub.docker.com/r/espressif/idf-rust/tags"><code>idf-rust</code></a> 镜像，<a href="writing-your-own-application/generate-project/../../installation/index.html">配置开发环境</a>中的<a href="writing-your-own-application/generate-project/../../installation/using-containers.html">使用容器</a>一节对此进行了解释。这个镜像提供了一个无需安装即可为乐鑫芯片开发 Rust 应用程序的环境。开发容器还可以与 <a href="https://wokwi.com/">Wokwi 模拟器</a>协作，以模拟项目，并允许使用 <a href="https://github.com/bjoernQ/esp-web-flash-server"><code>web-flash</code></a> 从容器中进行烧写。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp-template-简介"><a class="header" href="#esp-template-简介"><code>esp-template</code> 简介</a></h1>
<p>既然我们已经了解了如何<a href="writing-your-own-application/generate-project/./index.html">生成一个 <code>no_std</code> 项目</a>，让我们看看生成的项目里有哪些东西，
尝试理解它的各个部分，并运行它。</p>
<h2 id="检查生成的项目"><a class="header" href="#检查生成的项目">检查生成的项目</a></h2>
<p>从 <a href="https://github.com/esp-rs/esp-template"><code>esp-template</code></a> 创建项目，使用以下配置：</p>
<ul>
<li>Which MCU to target? · <code>esp32c3</code></li>
<li>Configure advanced template options? · <code>false</code></li>
</ul>
<p>在本节中，我们使用默认配置。如果需要进一步修改，请参阅 <a href="https://github.com/esp-rs/esp-template#esp-template">additional prompts</a>。</p>
<p>应该会生成类似这样的文件结构：</p>
<pre><code class="language-text">├── .cargo
│   └── config.toml
├── src
│   └── main.rs
├── .gitignore
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
└── rust-toolchain.toml
</code></pre>
<p>在进一步讨论之前，让我们看看这些文件的用途。</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>.cargo/config.toml</code></a>
<ul>
<li>Cargo 的配置</li>
<li>定义了一些用于正确构建项目的选项</li>
<li>包含 <code>runner = &quot;espflash flash --monitor&quot;</code> - 这意味着你可以用 <code>cargo run</code> 来烧写并监视代码</li>
</ul>
</li>
<li><code>src/main.rs</code>
<ul>
<li>项目的主要源文件</li>
<li>关于它的详细信息，请参阅下面的 <a href="writing-your-own-application/generate-project/esp-template.html#mainrs-%E7%AE%80%E4%BB%8B"><code>main.rs</code> 简介</a>一节</li>
</ul>
</li>
<li><a href="https://git-scm.com/docs/gitignore"><code>.gitignore</code></a>
<ul>
<li>指示 <code>git</code> 要忽略哪些目录和文件</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/manifest.html"><code>Cargo.toml</code></a>
<ul>
<li>Cargo 清单（manifest），通常声明了一些元数据和项目的依赖项</li>
</ul>
</li>
<li><code>LICENSE-APACHE</code>, <code>LICENSE_MIT</code>
<ul>
<li>这些是 Rust 生态中最常用的许可证</li>
<li>如果想使用其他许可证，可以删除这些文件，并修改 <code>Cargo.toml</code> 中的许可证</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><code>rust-toolchain.toml</code></a>
<ul>
<li>定义要使用的 Rust 工具链的种类
<ul>
<li>根据目标设备，工具链可以是 <code>nightly</code> 或 <code>esp</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="mainrs-简介"><a class="header" href="#mainrs-简介"><code>main.rs</code> 简介</a></h3>
<pre><code class="language-rust ignore"> 1 #![no_std]
 2 #![no_main]</code></pre>
<ul>
<li><code>#![no_std]</code>
<ul>
<li>用于告知 Rust 编译器这段代码不使用 <code>libstd</code></li>
</ul>
</li>
<li><code>#![no_main]</code>
<ul>
<li><code>no_main</code> 属性表示该程序不使用标准的 main 接口，该接口是为会接收参数的命令行应用设计的。我们将使用 <code>riscv-rt</code> crate 中的入口（entry）属性来创建一个自定义入口点（entry point），而不是使用标准的 main。在此程序中，我们将入口点命名为 <code>main</code>，但也可以使用任何其他名称。入口点函数必须是<a href="https://doc.rust-lang.org/beta/rust-by-example/fn/diverging.html">发散函数</a>，即具有签名 <code>fn foo() -&gt; !</code>，这种类型表明该函数永远不会返回——这意味着程序永远不会终止。</li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore"> 4 use esp_backtrace as _;
 5 use esp_println::println;
 6 use hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, timer::TimerGroup, Rtc};</code></pre>
<ul>
<li><code>use esp_backtrace as _;</code>
<ul>
<li>由于我们处于裸机环境中，因此需要一个 panic 处理程序，该处理程序在代码发生 panic 时运行</li>
<li>有多种不同的 crate 可选（例如 <code>panic-halt</code>），但是 <code>esp-backtrace</code> 提供了一个打印回溯地址的实现——与 <code>espflash</code>/<code>espmonitor</code> 配合，这些地址可以被解析为源代码中的位置</li>
</ul>
</li>
<li><code>use esp_println::println;</code>
<ul>
<li>提供了 <code>println!</code> 的实现</li>
</ul>
</li>
<li><code>use hal:{...}</code>
<ul>
<li>我们需要导入一些类型，以待后续使用</li>
<li>这些都是来自于 <code>esp-hal</code></li>
</ul>
</li>
</ul>
<pre><code class="language-rust ignore"> 8 #[entry]
 9 fn main() -&gt; ! {
10    let peripherals = Peripherals::take();
11    let mut system = peripherals.SYSTEM.split();
12    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();
13
14    // 禁用 RTC 和 TIMG 看门狗定时器
15    let mut rtc = Rtc::new(peripherals.RTC_CNTL);
16    let timer_group0 = TimerGroup::new(
17        peripherals.TIMG0,
18        &amp;clocks,
19        &amp;mut system.peripheral_clock_control,
20    );
21    let mut wdt0 = timer_group0.wdt;
22    let timer_group1 = TimerGroup::new(
23        peripherals.TIMG1,
24        &amp;clocks,
25        &amp;mut system.peripheral_clock_control,
26    );
27    rtc.swd.disable();
28    rtc.rwdt.disable();
29    wdt0.disable();
30    wdt1.disable();
31
32    println!(&quot;Hello world!&quot;);
33
34    loop {}
35 }</code></pre>
<p><code>main</code> 函数中包含：</p>
<ul>
<li><code>let peripherals = Peripherals::take().unwrap();</code>
<ul>
<li>HAL 驱动通常会通过 PAC（Peripheral Access Crate，外设访问 crate）获取到外设的所有权</li>
<li>这里我们从 PAC 中取出所有外设，之后将他们传递给 HAL 驱动</li>
</ul>
</li>
<li><code>let mut system = peripherals.SYSTEM.split();</code>
<ul>
<li>有时，外设（此处为 System 外设）是粗粒度的，并不完全适合 HAL 驱动——因此这里我们将 System 外设分割成更小的部分，然后传递给驱动程序</li>
</ul>
</li>
<li><code>let clocks = ClockControl::boot_defaults(system.clock_control).freeze();</code>
<ul>
<li>这里配置了系统时钟——本例中，使用默认值即可</li>
<li>然后我们冻结了时钟，之后就不能再次修改它了</li>
<li>某些驱动需要一个时钟的引用，以便知道如何计算速率和时长</li>
</ul>
</li>
<li>下一块代码实例化了一些外设（即 RTC 和两个定时器组）以禁用看门狗，看门狗是在上电时启用的
<ul>
<li>没有这段代码的话，SoC 会在一段时间后重启</li>
<li>还有一种防止重启的方法：<a href="https://docs.rs/esp32c3-hal/0.10.0/esp32c3_hal/prelude/trait._embedded_hal_watchdog_Watchdog.html#tymethod.feed">喂</a>看门狗</li>
</ul>
</li>
<li><code>println!(&quot;Hello world!&quot;);</code>
<ul>
<li>打印 “Hello world!”</li>
</ul>
</li>
<li><code>loop {}</code>
<ul>
<li>因为这个函数不应该返回，我们在一个死循环中不执行任何操作</li>
</ul>
</li>
</ul>
<h2 id="运行代码"><a class="header" href="#运行代码">运行代码</a></h2>
<p>构建和运行这段代码只需：</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>这会根据配置构建代码，并执行 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> 将其烧写到板子上。</p>
<p>由于 <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplerunner"><code>runner</code> 配置</a>还会将 <code>--monitor</code> 参数传递给 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>，屏幕上将显示打印的内容。</p>
<p>确保已经安装了 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>，否则此步骤会失败。执行此命令以安装 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>：
<code>cargo install espflash</code></p>
<p>屏幕上应该会显示类似这样的内容：</p>
<pre><code class="language-text">[2023-04-17T14:17:08Z INFO ] Serial port: '/dev/ttyACM0'
[2023-04-17T14:17:08Z INFO ] Connecting...
[2023-04-17T14:17:09Z INFO ] Using flash stub
[2023-04-17T14:17:09Z WARN ] Setting baud rate higher than 115,200 can cause issues
Chip type:         esp32c3 (revision v0.3)
Crystal frequency: 40MHz
Flash size:        4MB
Features:          WiFi, BLE
MAC address:       60:55:f9:c0:39:7c
App/part. size:    203,920/4,128,768 bytes, 4.94%
[00:00:00] [========================================]      13/13      0x0
[00:00:00] [========================================]       1/1       0x8000
[00:00:01] [========================================]      64/64      0x10000
[2023-04-17T14:17:11Z INFO ] Flashing has completed!
Commands:
    CTRL+R    Reset chip
    CTRL+C    Exit

...
Hello world!
</code></pre>
<p>这些是第一和第二阶段 bootloader 产生的信息，然后是我们的 “Hello world” 信息！</p>
<p>这就是这段代码做的事情。</p>
<p>可以按 <code>CTRL+R</code> 重启，或按 <code>CTRL+C</code> 退出。</p>
<p>如果在构建项目时遇到了什么问题，请查看 <a href="writing-your-own-application/generate-project/../../misc/troubleshooting.html">Troubleshooting</a> 章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="esp-idf-template-简介"><a class="header" href="#esp-idf-template-简介"><code>esp-idf-template</code> 简介</a></h1>
<p>既然我们已经了解了如何<a href="writing-your-own-application/generate-project/./index.html">生成一个 <code>std</code> 项目</a>，让我们看看生成的项目里有哪些东西，并尝试理解它的各个部分。</p>
<h2 id="检查生成的项目-1"><a class="header" href="#检查生成的项目-1">检查生成的项目</a></h2>
<p>从 <a href="https://github.com/esp-rs/esp-idf-template"><code>esp-idf-template</code></a> 创建项目，使用以下配置：</p>
<ul>
<li>Which MCU to target? · <code>esp32c3</code></li>
<li>Configure advanced template options? · <code>false</code></li>
</ul>
<p>在本节中，我们使用默认配置。如果需要进一步修改，请参阅 <a href="https://github.com/esp-rs/esp-idf-template#generate-the-project">additional prompts</a>。</p>
<p>应该会生成类似这样的文件结构：</p>
<pre><code class="language-text">├── .cargo
│   └── config.toml
├── src
│   └── main.rs
├── .gitignore
├── build.rs
├── Cargo.toml
├── rust-toolchain.toml
└── sdkconfig.defaults
</code></pre>
<p>在进一步讨论之前，让我们看看这些文件的用途。</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/config.html"><code>.cargo/config.toml</code></a>
<ul>
<li>Cargo 的配置</li>
<li>包含项目的目标</li>
<li>包含 <code>runner = &quot;espflash flash --monitor&quot;</code> - 这意味着你可以用 <code>cargo run</code> 来烧写并监视代码</li>
<li>包含要使用的链接器，在这里是 <a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a></li>
<li>启用了不稳定的 Cargo 特性 <code>build-std</code></li>
<li>包含 <code>ESP-IDF-VERSION</code> 环境变量，用于告知 <a href="https://github.com/esp-rs/esp-idf-sys"><code>esp-idf-sys</code></a> 本项目要使用哪个版本的 ESP-IDF</li>
</ul>
</li>
<li><code>src/main.rs</code>
<ul>
<li>项目的主要源文件</li>
<li>关于它的详细信息，请参阅下面的 <a href="writing-your-own-application/generate-project/esp-idf-template.html#mainrs-%E7%AE%80%E4%BB%8B"><code>main.rs</code> 简介</a></li>
</ul>
</li>
<li><a href="https://git-scm.com/docs/gitignore"><code>.gitignore</code></a>
<ul>
<li>指示 <code>git</code> 要忽略哪些目录和文件</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code></a>
<ul>
<li>将链接参数传递给 <code>ldproxy</code></li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/cargo/reference/manifest.html"><code>Cargo.toml</code></a>
<ul>
<li>Cargo 清单（manifest），通常声明了一些元数据和项目的依赖项</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><code>rust-toolchain.toml</code></a>
<ul>
<li>定义要使用的 Rust 工具链的种类
<ul>
<li>根据目标设备，工具链可以是 <code>nightly</code> 或 <code>esp</code></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/build-system.html#custom-sdkconfig-defaults"><code>sdkconfig.defaults</code></a>
<ul>
<li>包含一些配置，用于覆盖 ESP-IDF 的默认值</li>
</ul>
</li>
</ul>
<h3 id="mainrs-简介-1"><a class="header" href="#mainrs-简介-1"><code>main.rs</code> 简介</a></h3>
<pre><code class="language-rust ignore">1 use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
2
3 fn main() {
4     // It is necessary to call this function once. Otherwise some patches to the runtime
5     // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
6     esp_idf_sys::link_patches();
7     println!(&quot;Hello, world!&quot;);
8 }</code></pre>
<p>第一行是一个导入语句，定义了 ESP-IDF 的入口点（当根 crate 是定义了 main 函数的二进制 crate 时）。</p>
<p>然后，下面是一个普通的 main 函数，其中有几行代码：</p>
<ul>
<li>调用 <code>esp_idf_sys::link_patches</code> 函数，确保一些用 Rust 实现的 ESP-IDF 补丁能够被链接到最终的可执行文件里。</li>
<li>在控制台里打印著名的 “Hello, world!”</li>
</ul>
<h2 id="运行代码-1"><a class="header" href="#运行代码-1">运行代码</a></h2>
<p>构建和运行这段代码只需：</p>
<pre><code class="language-shell">cargo run
</code></pre>
<p>这会根据配置构建代码，并执行 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a> 将其烧写到板子上。</p>
<p>由于 <a href="https://doc.rust-lang.org/cargo/reference/config.html#targettriplerunner"><code>runner</code> 配置</a>还会将 <code>--monitor</code> 参数传递给 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>，屏幕上将显示打印的内容。</p>
<p>确保已经安装了 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>，否则此步骤会失败。执行此命令以安装 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>：
<code>cargo install espflash</code></p>
<p>屏幕上应该会显示类似这样的内容：</p>
<pre><code class="language-text">[2023-04-18T08:05:09Z INFO ] Connecting...
[2023-04-18T08:05:10Z INFO ] Using flash stub
[2023-04-18T08:05:10Z WARN ] Setting baud rate higher than 115,200 can cause issues
Chip type:         esp32c3 (revision v0.3)
Crystal frequency: 40MHz
Flash size:        4MB
Features:          WiFi, BLE
MAC address:       60:55:f9:c0:39:7c
App/part. size:    478,416/4,128,768 bytes, 11.59%
[00:00:00] [========================================]      13/13      0x0
[00:00:00] [========================================]       1/1       0x8000
[00:00:04] [========================================]     227/227     0x10000
[2023-04-18T08:05:15Z INFO ] Flashing has completed!
Commands:
    CTRL+R    Reset chip
    CTRL+C    Exit

...
I (344) cpu_start: Starting scheduler.
Hello, world!
</code></pre>
<p>如你所见，这些是第一和第二阶段 bootloader 产生的信息，然后是我们的 “Hello, world!”。</p>
<p>可以按 <code>CTRL+R</code> 重启，或按 <code>CTRL+C</code> 退出。</p>
<p>如果在构建项目时遇到了什么问题，请查看 <a href="writing-your-own-application/generate-project/../../misc/troubleshooting.html">Troubleshooting</a> 章节。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写-no_std-应用"><a class="header" href="#编写-no_std-应用">编写 <code>no_std</code> 应用</a></h1>
<p>如果你想要学习如何开发 <code>no_std</code> 应用，可以阅读以下材料：</p>
<ul>
<li>书：<a href="https://esp-rs.github.io/no_std-training/">Embedded Rust (<code>no_std</code>) on Espressif</a></li>
<li>仓库：<a href="https://github.com/esp-rs/no_std-training"><code>no_std-training</code></a></li>
</ul>
<p>这个教程是基于 <a href="https://github.com/esp-rs/esp-rust-board">ESP32-C3-DevKit-RUST-1</a> 开发板的。也可以使用其他乐鑫开发板，但是可能需要修改代码和项目配置。</p>
<p>这个教程包含：</p>
<ul>
<li>入门示例：
<ul>
<li><a href="https://github.com/esp-rs/no_std-training/tree/main/intro/hello-world">基本的 hello-world</a></li>
<li><a href="https://github.com/esp-rs/no_std-training/tree/main/intro/panic">panic 示例</a></li>
<li><a href="https://github.com/esp-rs/no_std-training/tree/main/intro/blinky">点灯示例</a></li>
<li><a href="https://github.com/esp-rs/no_std-training/tree/main/intro/button">按钮示例</a></li>
<li><a href="https://github.com/esp-rs/no_std-training/tree/main/intro/button-interrupt">按钮+中断示例</a></li>
</ul>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>注意</strong>：每个 SoC <a href="https://github.com/esp-rs/esp-hal"><code>esp-hal</code></a> 的示例文件夹下都有几个示例，涵盖了特定外设的使用方法。例如 <a href="https://github.com/esp-rs/esp-hal/tree/main/esp32c3-hal/examples"><code>esp32c3-hal/examples</code></a>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写-std-应用"><a class="header" href="#编写-std-应用">编写 <code>std</code> 应用</a></h1>
<p>如果你想要学习如何开发 <code>std</code> 应用，可以阅读这些我们与 <a href="https://ferrous-systems.com/">Ferrous Systems</a> 合作编写的材料：</p>
<ul>
<li>书：<a href="https://esp-rs.github.io/std-training/">Embedded Rust on Espressif</a></li>
<li>仓库：<a href="https://github.com/esp-rs/std-training"><code>std-training</code></a></li>
</ul>
<p>这个教程是基于 <a href="https://github.com/esp-rs/esp-rust-board">ESP32-C3-DevKit-RUST-1</a> 开发板的。也可以使用其他乐鑫开发板，但是可能需要修改代码和项目配置。</p>
<p>这个教程包含两个部分：</p>
<ul>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro">入门示例</a>：
<ul>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro/hardware-check">基本硬件检查</a></li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro/http-client">HTTP 客户端</a></li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro/http-server">HTTP 服务器</a></li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/intro/mqtt">MQTT 客户端</a></li>
</ul>
</li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/advanced">进阶示例</a>：
<ul>
<li>底层 GPIO</li>
<li>中断</li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/advanced/i2c-driver">I2C 驱动</a></li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/advanced/i2c-sensor-reading">读取 I2C 传感器</a></li>
<li><a href="https://github.com/esp-rs/std-training/tree/main/advanced/button-interrupt">GPIO/按钮中断</a></li>
<li>驱动 RGB LED</li>
</ul>
</li>
</ul>
<blockquote>
<p>⚠️ <strong>注意</strong>：<a href="https://github.com/esp-rs/esp-idf-hal"><code>esp-idf-hal</code></a> 的示例文件夹下有几个示例，涵盖了特定外设的使用方法。即 <a href="https://github.com/esp-rs/esp-idf-hal/tree/master/examples"><code>esp-idf-hal/examples</code></a>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工具"><a class="header" href="#工具">工具</a></h1>
<p>现在我们已经安装了所需的依赖项，并知道如何生成模板项目，我们将更详细地介绍一些工具。这些工具将使为乐鑫芯片开发 Rust 应用程序变得更加容易。</p>
<p>在本章中，我们将介绍 <code>espflash</code>/<code>cargo-espflash</code>，建议使用 Visual Studio Code 作为 IDE，并深入探讨当前可用的仿真和调试方法。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h1>
<p>Microsoft 的 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 文本编辑器以及 <a href="https://rust-analyzer.github.io/">Rust Analyzer</a> 扩展，也称为 RA，是较常见的开发环境之一。</p>
<p>Visual Studio Code 是一个开源的跨平台图形化文本编辑器，具有丰富的扩展生态系统。<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Rust Analyzer 扩展</a>为 Rust 提供了 <a href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol（语言服务器协议</a>的实现，并包括自动完成、跳转到定义等功能。</p>
<p>Visual Studio Code 可以通过大多数流行的软件包管理器安装，也可以在官方网站上获得安装程序。<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">Rust Analyzer 扩展</a>可以通过内置的扩展管理器在 Visual Studio Code 中安装。</p>
<p>除了 Rust Analyzer 之外，其他扩展也可能有所帮助：</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better TOML</a>用于编辑基于 TOML 的配置文件</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=serayuzgur.crates">crates</a>用于帮助管理 Rust 依赖项</li>
</ul>
<h2 id="实用建议"><a class="header" href="#实用建议">实用建议</a></h2>
<h3 id="在-no_std-下使用-rust-analyzer"><a class="header" href="#在-no_std-下使用-rust-analyzer">在 <code>no_std</code> 下使用 Rust Analyzer</a></h3>
<p>如果为不支持 <code>std</code> 的目标开发，Rust Analyzer 可能会表现出奇怪的行为，通常会报告各种错误。这可以通过在项目中创建 <code>.vscode/settings.json</code> 文件并填充以下内容来解决：</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.checkOnSave.allTargets&quot;: false
}
</code></pre>
<h3 id="在使用自定义工具链时使用-cargo-提示"><a class="header" href="#在使用自定义工具链时使用-cargo-提示">在使用自定义工具链时使用 Cargo 提示</a></h3>
<p>如果正在使用自定义工具链，就像在 <code>Xtensa</code> 目标中一样，可以通过 <code>rust-toolchain.toml</code> 文件向 <code>cargo</code> 提供一些提示，以改善用户体验：</p>
<pre><code class="language-toml">[toolchain]
channel = &quot;esp&quot;
components = [&quot;rustfmt&quot;, &quot;rustc-dev&quot;]
targets = [&quot;xtensa-esp32-none-elf&quot;]
</code></pre>
<h2 id="其他-ide"><a class="header" href="#其他-ide">其他 IDE</a></h2>
<p>选择介绍 VS Code 是因为它对 Rust 有很好的支持，并且在开发者中很受欢迎。还有其他一些 IDE 也有相当的 Rust 支持，如 CLion 和 vim，但这些不在本书的讨论范围内。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="espflash"><a class="header" href="#espflash"><code>espflash</code></a></h1>
<p><code>espflash</code> 是一个基于 <a href="https://github.com/espressif/esptool">esptool.py</a> 的乐鑫 SoC 和模块的串口下载工具。</p>
<p><a href="https://github.com/esp-rs/espflash"><code>espflash</code></a> 仓库包含两个 crate，<code>cargo-espflash</code> 和 <code>espflash</code>。有关这些 crate 的更多信息，请参见下面的各自部分。</p>
<blockquote>
<p>⚠️ <strong>注意</strong>: 下面显示的 <code>espflash</code> 和 <code>cargo-espflash</code> 命令，假定使用 <code>2.0</code> 或更高版本。</p>
</blockquote>
<h2 id="cargo-espflash"><a class="header" href="#cargo-espflash"><code>cargo-espflash</code></a></h2>
<p>为 <code>cargo</code> 提供一个子命令，处理交叉编译和下载。</p>
<p>要安装，请运行：</p>
<pre><code class="language-shell">cargo install cargo-espflash
</code></pre>
<p>此命令必须在 Cargo 项目中运行，即包含 <code>Cargo.toml</code> 文件的目录。例如，要构建名为 “blinky” 的示例，将生成的二进制文件下载到设备中，然后启动串行监视器：</p>
<pre><code class="language-shell">cargo espflash flash --example=blinky --monitor
</code></pre>
<p>有关更多信息，请参见 <a href="https://github.com/esp-rs/espflash/blob/master/cargo-espflash/README.md"><code>cargo-espflash</code></a> README。</p>
<h2 id="espflash-1"><a class="header" href="#espflash-1"><code>espflash</code></a></h2>
<p>提供一个独立的命令行应用程序，将 ELF 文件下载到设备中。</p>
<p>要安装，请运行：</p>
<pre><code class="language-shell">cargo install espflash
</code></pre>
<p>假设你已经通过其他方式构建了 ELF 二进制文件，<code>espflash</code> 可以用于将其下载到设备并监视串行端口。例如，如果你已经使用 <code>idf.py</code> 从 <a href="https://github.com/espressif/esp-idf">ESP-IDF</a> 构建了名为 “getting-started/blinky” 的示例，可以运行类似以下的命令：</p>
<pre><code class="language-shell">espflash flash build/blinky --monitor
</code></pre>
<p>有关更多信息，请参见 <a href="https://github.com/esp-rs/espflash/blob/master/espflash/README.md"><code>espflash</code> README</a>。</p>
<p><code>espflash</code> 可以通过在你的项目的 <code>.cargo/config.toml</code> 文件中添加以下内容，作为 Cargo runner 来使用：</p>
<pre><code class="language-toml">[target.'cfg(any(target_arch = &quot;riscv32&quot;, target_arch = &quot;xtensa&quot;))']
runner = &quot;espflash flash --monitor&quot;
</code></pre>
<p>使用此配置，可以通过 <code>cargo run</code> 下载和监控应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试"><a class="header" href="#调试">调试</a></h1>
<p>在本章中，我们将介绍使用不同工具进行调试 Rust 应用程序的方法。</p>
<p>请参考下表，了解每种调试方法支持的芯片：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><strong>probe-rs</strong></th><th style="text-align: center"><strong>OpenOCD</strong></th><th style="text-align: center"><strong>VS Code</strong></th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>ESP32</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C6</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-H2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S2</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S3</strong></td><td style="text-align: center">❌</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="probe-rs"><a class="header" href="#probe-rs"><code>probe-rs</code></a></h1>
<p><a href="https://probe.rs/"><code>probe-rs</code></a> 项目是一组工具，用于使用各种调试探针与嵌入式 MCU 进行交互。它类似于 <a href="https://openocd.org/">OpenOCD</a>、<a href="https://pyocd.io/">pyOCD</a>、<a href="https://www.segger.com/">Segger 工具</a>等。支持 <code>ARM</code> 和 <code>RISC-V</code> 架构以及一系列工具，包括但不限于：</p>
<ul>
<li>调试器
<ul>
<li>GDB 支持。</li>
<li>用于交互式调试的 CLI。</li>
<li>VS Code 扩展。</li>
</ul>
</li>
<li>实时传输（RTT）
<ul>
<li>类似于 IDF 的 app_trace 组件。</li>
</ul>
</li>
<li>烧录算法</li>
</ul>
<p>有关 probe-rs 及如何设置项目的更多信息，请参见 <a href="https://probe.rs/">probe-rs</a> 网站。</p>
<h2 id="esp32-c3-的-usb-jtag-serial-外设"><a class="header" href="#esp32-c3-的-usb-jtag-serial-外设">ESP32-C3 的 <code>USB-JTAG-SERIAL</code> 外设</a></h2>
<p>从 <code>probe-rs</code> v0.12 开始，可以使用内置的 <code>USB-JTAG-SERIAL</code> 外设对 ESP32-C3 进行烧录和调试，无需任何外部硬件调试器。有关配置接口的更多信息，请参见<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/configure-builtin-jtag.html">官方文档</a>。</p>
<h2 id="乐鑫芯片的支持"><a class="header" href="#乐鑫芯片的支持">乐鑫芯片的支持</a></h2>
<p><code>probe-rs</code> 目前仅支持 <code>ARM</code> 和 <code>RISC-V</code>，因此目前限制了可以使用的乐鑫芯片数量。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">芯片</th><th style="text-align: center">烧录</th><th style="text-align: center">调试</th></tr></thead><tbody>
<tr><td style="text-align: center">ESP32-C3</td><td style="text-align: center">✅</td><td style="text-align: center">⚠️</td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ <strong>注意</strong>：<em>标有 ⚠️ 的项目目前正在进行中，可用但可能存在错误。</em></p>
</blockquote>
<h2 id="权限---linux"><a class="header" href="#权限---linux">权限 - Linux</a></h2>
<p>在 Linux 上，可能会遇到与乐鑫探针交互时的权限问题。安装以下 <code>udev</code> 规则并重新加载应该可以解决此问题。</p>
<pre><code class="language-text"># Espressif dev kit FTDI
ATTRS{idVendor}==&quot;0403&quot;, ATTRS{idProduct}==&quot;6010&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB JTAG/serial debug unit
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1001&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;

# Espressif USB Bridge
ATTRS{idVendor}==&quot;303a&quot;, ATTRS{idProduct}==&quot;1002&quot;, MODE=&quot;660&quot;, GROUP=&quot;plugdev&quot;, TAG+=&quot;uaccess&quot;
</code></pre>
<!-- TODO: 当probe-rs可以实际调试至少具有良好回溯等功能的C3时，在此处添加一个示例配置：参见https://github.com/probe-rs/probe-rs/issues/877 -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="openocd"><a class="header" href="#openocd">OpenOCD</a></h1>
<p>与 <a href="tooling/debugging/./probe-rs.html"><code>probe-rs</code></a> 类似，OpenOCD 不支持 <code>Xtensa</code> 架构。然而，乐鑫在 <a href="https://github.com/espressif/openocd-esp32">espressif/openocd-esp32</a> 下维护了一个 OpenOCD 的分支，该分支支持乐鑫的芯片。</p>
<p>有关如何在你的平台上安装 <code>openocd-esp32</code> 的说明可以在<a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/api-guides/jtag-debugging/index.html#setup-of-openocd">乐鑫文档</a>中找到。</p>
<h2 id="乐鑫芯片的设置"><a class="header" href="#乐鑫芯片的设置">乐鑫芯片的设置</a></h2>
<!-- how to choose interface & chip -->
<p>安装完成后，只需使用正确的脚本运行 <code>openocd</code> 即可。对于具有内置 USB JTAG 的芯片，通常有一个可以直接使用的配置，例如在 ESP32-C3 上：</p>
<pre><code class="language-shell">openocd -f board/esp32c3-builtin.cfg
</code></pre>
<p>对于其他配置，可能需要指定芯片和接口，例如，使用 J-Link 的 ESP32：</p>
<pre><code class="language-shell">openocd -f interface/jlink.cfg -f target/esp32.cfg
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在-visual-studio-code-中进行调试"><a class="header" href="#在-visual-studio-code-中进行调试">在 Visual Studio Code 中进行调试</a></h1>
<p>在 Visual Studio Code 中，还可以直接进行可视化的调试。</p>
<h2 id="esp32"><a class="header" href="#esp32">ESP32</a></h2>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<ol>
<li>连接外部 JTAG 适配器：可以使用 <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a>。</li>
</ol>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32 引脚</th><th style="text-align: center">JTAG 信号</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO15</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO12</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO13</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO14</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ <strong>注意</strong>：在 Windows 上，<code>USB Serial Converter A 0403 6010 00</code> 驱动程序应为 WinUSB。</p>
</blockquote>
<ol start="2">
<li>设置 VSCode
<ol>
<li>安装 VS Code 的 <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> 扩展。</li>
<li>在要调试的项目树中创建 <code>.vscode/launch.json</code> 文件。</li>
<li>更新 <code>executable</code>、<code>svdFile</code>、<code>serverpath</code> 路径和 <code>toolchainPrefix</code> 字段。</li>
</ol>
</li>
</ol>
<pre><code class="language-json">{
  // 使用IntelliSense了解可能的属性。
  // 悬停以查看现有属性的描述。
  // 有关更多信息，请访问：https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      // 更多信息请参见：https://github.com/Marus/cortex-debug/blob/master/package.json
      &quot;name&quot;: &quot;Attach&quot;,
      &quot;type&quot;: &quot;cortex-debug&quot;,
      &quot;request&quot;: &quot;attach&quot;, // 使用 attach 而不是 launch，避免因为尝试写入 flash 导致运行失败
      &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
      &quot;executable&quot;: &quot;target/xtensa-esp32-none-elf/debug/.....&quot;,
      &quot;servertype&quot;: &quot;openocd&quot;,
      &quot;interface&quot;: &quot;jtag&quot;,
      &quot;svdFile&quot;: &quot;../../esp-pacs/esp32/svd/esp32.svd&quot;,
      &quot;toolchainPrefix&quot;: &quot;xtensa-esp32-elf&quot;,
      &quot;openOCDPreConfigLaunchCommands&quot;: [&quot;set ESP_RTOS none&quot;],
      &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
      &quot;configFiles&quot;: [&quot;board/esp32-wrover-kit-3.3v.cfg&quot;],
      &quot;overrideAttachCommands&quot;: [
        &quot;set remote hardware-watchpoint-limit 2&quot;,
        &quot;mon halt&quot;,
        &quot;flushregs&quot;
      ],
      &quot;overrideRestartCommands&quot;: [&quot;mon reset halt&quot;, &quot;flushregs&quot;, &quot;c&quot;]
    }
  ]
}
</code></pre>
<h2 id="esp32-c3"><a class="header" href="#esp32-c3">ESP32-C3</a></h2>
<p>内置 JTAG 接口的可用性取决于 ESP32-C3 版本：</p>
<ul>
<li>早于 3 的版本<strong>没有</strong>内置 JTAG 接口。</li>
<li>版本 3（及更高版本）<strong>具有</strong>内置 JTAG 接口，无需连接外部设备即可进行调试。</li>
</ul>
<p>要查找 ESP32-C3 版本，请运行：</p>
<pre><code class="language-shell">cargo espflash board-info
# 或者
espflash board-info
</code></pre>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<p>1.（<strong>仅适用于早于 3 的版本</strong>）连接外部 JTAG 适配器，可以使用 <a href="https://docs.espressif.com/projects/espressif-esp-iot-solution/en/latest/hw-reference/ESP-Prog_guide.html">ESP-Prog</a>。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">ESP32-C3 引脚</th><th style="text-align: center">JTAG 信号</th></tr></thead><tbody>
<tr><td style="text-align: center">MTDO/GPIO7</td><td style="text-align: center">TDO</td></tr>
<tr><td style="text-align: center">MTDI/GPIO5</td><td style="text-align: center">TDI</td></tr>
<tr><td style="text-align: center">MTCK/GPIO6</td><td style="text-align: center">TCK</td></tr>
<tr><td style="text-align: center">MTMS/GPIO4</td><td style="text-align: center">TMS</td></tr>
<tr><td style="text-align: center">3V3</td><td style="text-align: center">VJTAG</td></tr>
<tr><td style="text-align: center">GND</td><td style="text-align: center">GND</td></tr>
</tbody></table>
</div>
<blockquote>
<p>⚠️ <strong>注意</strong>：在 Windows 上，<code>USB Serial Converter A 0403 6010 00</code> 驱动程序应为 WinUSB。</p>
</blockquote>
<ol start="2">
<li>设置 VSCode
<ol>
<li>安装 VS Code 的 <a href="https://marketplace.visualstudio.com/items?itemName=marus25.cortex-debug">Cortex-Debug</a> 扩展。</li>
<li>在要调试的项目树中创建 <code>.vscode/launch.json</code> 文件。</li>
<li>更新 <code>executable</code>、<code>svdFile</code>、<code>serverpath</code> 路径和 <code>toolchainPrefix</code> 字段。</li>
</ol>
</li>
</ol>
<pre><code class="language-json">{
  // 使用IntelliSense了解可能的属性。
  // 悬停以查看现有属性的描述。
  // 有关更多信息，请访问：https://go.microsoft.com/fwlink/?linkid=830387
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      // 更多信息请参见：https://github.com/Marus/cortex-debug/blob/master/package.json
      &quot;name&quot;: &quot;Attach&quot;,
      &quot;type&quot;: &quot;cortex-debug&quot;,
      &quot;request&quot;: &quot;attach&quot;, // 使用 attach 而不是 launch，避免因为尝试写入 flash 导致运行失败
      &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
      &quot;executable&quot;: &quot;target/riscv32imc-unknown-none-elf/debug/examples/usb_serial_jtag&quot;, //
      &quot;servertype&quot;: &quot;openocd&quot;,
      &quot;interface&quot;: &quot;jtag&quot;,
      &quot;svdFile&quot;: &quot;../../esp-pacs/esp32c3/svd/esp32c3.svd&quot;,
      &quot;toolchainPrefix&quot;: &quot;riscv32-esp-elf&quot;,
      &quot;openOCDPreConfigLaunchCommands&quot;: [&quot;set ESP_RTOS none&quot;],
      &quot;serverpath&quot;: &quot;C:/Espressif/tools/openocd-esp32/v0.11.0-esp32-20220411/openocd-esp32/bin/openocd.exe&quot;,
      &quot;configFiles&quot;: [&quot;board/esp32c3-builtin.cfg&quot;],
      &quot;overrideAttachCommands&quot;: [
        &quot;set remote hardware-watchpoint-limit 2&quot;,
        &quot;mon halt&quot;,
        &quot;flushregs&quot;
      ],
      &quot;overrideRestartCommands&quot;: [&quot;mon reset halt&quot;, &quot;flushregs&quot;, &quot;c&quot;]
    }
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="仿真"><a class="header" href="#仿真">仿真</a></h1>
<p>仿真可能很方便。它允许用户使用 CI（持续集成）来测试项目、在没有可用硬件的情况下尝试项目，还有许多其他使用场景。</p>
<p>目前，有多种方法可以在乐鑫芯片上仿真 Rust 项目。每种方法都有一些限制，但它们正在迅速发展，并且每天都在变得更好。</p>
<p>在本章中，我们将讨论当前可用的仿真工具。</p>
<p>请参考下表，以了解每种仿真方法支持哪种芯片：</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><strong><a href="https://docs.wokwi.com/guides/esp32#simulation-features">Wokwi</a></strong></th><th style="text-align: center"><strong>QEMU</strong></th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>ESP32</strong></td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C2</strong></td><td style="text-align: center">❌</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-C6</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-H2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S2</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
<tr><td style="text-align: center"><strong>ESP32-S3</strong></td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="wokwi"><a class="header" href="#wokwi">Wokwi</a></h1>
<p><a href="https://wokwi.com/">Wokwi</a> 是一个在线模拟器，支持在乐鑫芯片上模拟 Rust 项目（包括 <code>std</code> 和 <code>no_std</code>）。
请参考 <a href="https://wokwi.com/rust">wokwi.com/rust</a> 以获取示例列表和开始新项目的方法。</p>
<p>Wokwi 提供了 Wi-Fi 仿真、虚拟逻辑分析仪和 <a href="https://docs.wokwi.com/zh-CN/gdb-debugging">GDB 调试</a>等许多功能，请参考 <a href="https://docs.wokwi.com/zh-CN/">Wokwi 文档</a>以获取更多详细信息。
对于 ESP 芯片，有一个<a href="https://docs.wokwi.com/zh-CN/guides/esp32#simulation-features">仿真功能</a>表格，列出了当前支持的功能。</p>
<h2 id="使用-wokwi-vs-code-扩展"><a class="header" href="#使用-wokwi-vs-code-扩展">使用 Wokwi VS Code 扩展</a></h2>
<p>Wokwi 提供了一个 VS Code 扩展，允许通过添加几个文件直接在代码编辑器中模拟项目。
更多信息，请参考 <a href="https://docs.wokwi.com/zh-CN/vscode/getting-started">Wokwi 文档</a>。
还可以使用 VS Code 调试器调试代码，请参考<a href="https://docs.wokwi.com/zh-CN/vscode/debugging">调试你的代码</a>。</p>
<p>当使用任何<a href="tooling/simulating/./../../writing-your-own-application/generate-project/index.html">模板</a>并且不使用默认值时，会有一个提示（<code>Configure project to support Wokwi simulation with Wokwi VS Code extension?</code>），可以生成使用 Wokwi VS Code 扩展所必需的文件。</p>
<p><img src="tooling/simulating/../../assets/wokwi-vscode.png" alt="Wokwi VS Code示例" /></p>
<h2 id="使用-wokwi-server"><a class="header" href="#使用-wokwi-server">使用 <code>wokwi-server</code></a></h2>
<p><a href="https://github.com/MabezDev/wokwi-server"><code>wokwi-server</code></a> 是一个 CLI 工具，用于启动项目的 Wokwi 仿真。也就是说，它允许在本地或容器中构建项目，并模拟生成的二进制文件。</p>
<p><a href="https://github.com/MabezDev/wokwi-server"><code>wokwi-server</code></a> 还允许在其他 Wokwi 项目上模拟二进制文件，除了芯片本身外还有更多的硬件部件。请参考 <a href="https://github.com/MabezDev/wokwi-server#simulating-your-binary-on-a-custom-wokwi-project"><code>wokwi-server README</code> 的相应部分</a> 以获取详细说明。</p>
<h2 id="自定义芯片"><a class="header" href="#自定义芯片">自定义芯片</a></h2>
<p>Wokwi 允许生成自定义芯片，让你对 Wokwi 不支持的组件的行为进行编程。更多详情，请参考官方 <a href="https://docs.wokwi.com/chips-api/getting-started">Wokwi 文档</a>。</p>
<p>自定义芯片也可以用 Rust 编写！请参考 <a href="https://github.com/wokwi/wokwi_chip_ll">Wokwi Custom Chip API</a> 以获取更多信息。例如，使用 Rust 编写的自定义<a href="https://github.com/wokwi/rust_chip_inverter">反相器芯片</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qemu"><a class="header" href="#qemu">QEMU</a></h1>
<p>乐鑫维护了一个 QEMU 的分支，位于 <a href="https://github.com/espressif/qemu">espressif/QEMU</a>，其中包含了必要的补丁，使其能够在乐鑫芯片上运行。
请参考 <a href="https://github.com/espressif/qemu/wiki">QEMU wiki</a> 以了解如何构建 QEMU 并使用它来仿真项目。</p>
<p>构建完成 QEMU 后，应该有 <code>qemu-system-xtensa</code> 文件。</p>
<h2 id="使用-qemu-运行项目"><a class="header" href="#使用-qemu-运行项目">使用 QEMU 运行项目</a></h2>
<blockquote>
<p>⚠️ <strong>注意</strong>: 目前只支持 ESP32，因此请确保正在编译 <code>xtensa-esp32-espidf</code> 目标。</p>
</blockquote>
<p>要在 QEMU 中运行我们的项目，我们需要一个固件（firmware）/镜像（image），其中包含引导加载程序（bootloader）和分区表。
我们可以使用 <a href="https://github.com/esp-rs/espflash/tree/main/cargo-espflash"><code>cargo-espflash</code></a> 来生成它：</p>
<pre><code class="language-shell">cargo espflash save-image --chip esp32 --merge &lt;OUTFILE&gt; --release
</code></pre>
<p>如果想使用 <a href="https://github.com/esp-rs/espflash/tree/main/espflash"><code>espflash</code></a>，可以先构建项目，然后生成镜像来实现相同的结果：</p>
<pre><code class="language-shell">cargo build --release
espflash save-image --merge ESP32 target/xtensa-esp32-espidf/release/&lt;NAME&gt; &lt;OUTFILE&gt;
</code></pre>
<p>现在，在 QEMU 中运行镜像：</p>
<pre><code class="language-shell">/path/to/qemu-system-xtensa -nographic -machine esp32 -drive file=&lt;OUTFILE&gt;,if=mtd,format=raw
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>在这里，我们将列出构建项目时常见的错误，及其原因和解决方案。</p>
<h2 id="未设置-libclang_path-环境变量"><a class="header" href="#未设置-libclang_path-环境变量">未设置 <code>LIBCLANG_PATH</code> 环境变量</a></h2>
<pre><code class="language-text">thread 'main' panicked at 'Unable to find libclang: &quot;couldn't find any valid shared libraries matching: ['libclang.so', 'libclang-*.so', 'libclang.so.*', 'libclang-*.so.*'], set the `LIBCLANG_PATH` environment variable to a path where one of these files can be found (invalid: [])&quot;', /home/esp/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.60.1/src/lib.rs:2172:31
</code></pre>
<p>我们需要 <code>libclang</code> 来让 <a href="https://github.com/rust-lang/rust-bindgen"><code>bindgen</code></a> 生成 ESP-IDF C 头文件到 Rust 的绑定。
确保你已经 source 了 <code>espup</code> 生成的 export 文件，请参阅<a href="misc/./../installation/riscv-and-xtensa.html#3-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">配置环境变量</a>。</p>
<h2 id="缺少-ldproxy"><a class="header" href="#缺少-ldproxy">缺少 <code>ldproxy</code></a></h2>
<pre><code class="language-shell">error: linker `ldproxy` not found
  |
  = note: No such file or directory (os error 2)
</code></pre>
<p>要构建 <code>std</code> 应用，必须安装 <a href="https://github.com/esp-rs/embuild/tree/master/ldproxy"><code>ldproxy</code></a>。请参阅 <a href="misc/./../installation/std-requirements.html"><code>std</code> 开发依赖项</a></p>
<pre><code class="language-shell">cargo install ldproxy
</code></pre>
<h2 id="使用了错误的-rust-工具链"><a class="header" href="#使用了错误的-rust-工具链">使用了错误的 Rust 工具链</a></h2>
<pre><code class="language-text">$ cargo build
error: failed to run `rustc` to learn about target-specific information

Caused by:
  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names --target xtensa-esp32-espidf --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit status: 1)
  --- stderr
  error: Error loading target specification: Could not find specification for target &quot;xtensa-esp32-espidf&quot;. Run `rustc --print target-list` for a list of built-in targets
</code></pre>
<p>如果遇到了上面的错误，或类似的错误，可能是因为没有使用合适的 Rust 工具链。注意：对于 <code>Xtensa</code> 目标，需要使用乐鑫分支的 Rust 工具链，有这几种方法：</p>
<ul>
<li>在命令行中使用<a href="https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand">工具链 override</a> 简写： <code>cargo +esp</code>。</li>
<li>将 <code>RUSTUP_TOOLCHAIN</code> 环境变量设置为 <code>esp</code>。</li>
<li>设置<a href="https://rust-lang.github.io/rustup/overrides.html#directory-overrides">目录 override</a>：<code>rustup override set esp</code></li>
<li>在项目中添加 <a href="https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file"><code>rust-toolchain.toml</code></a> 文件：
<pre><code class="language-toml">[toolchain]
channel = &quot;esp&quot;
</code></pre>
</li>
<li>将 <code>esp</code> 设置为<a href="https://rust-lang.github.io/rustup/overrides.html#default-toolchain">默认工具链</a>。</li>
</ul>
<p>关于工具链 override 的更多信息，请参阅 The rustup book 的 <a href="https://rust-lang.github.io/rustup/overrides.html#overrides">Overrides chapter</a> 章节。</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<h3 id="长路径名"><a class="header" href="#长路径名">长路径名</a></h3>
<p>使用 Windows 时，如果使用了长路径名，你可能会在构建新项目时遇到问题。请按照以下步骤替换项目的路径：</p>
<pre><code class="language-powershell">subst r: &lt;你的项目的路径&gt;
cd r:\
</code></pre>
<h3 id="缺失-abi"><a class="header" href="#缺失-abi">缺失 ABI</a></h3>
<pre><code class="language-powershell">  Compiling cc v1.0.69
error: linker `link.exe` not found
  |
  = note: The system cannot find the file specified. (os error 2)

note: the msvc targets depend on the msvc linker but `link.exe` was not found

note: please ensure that VS 2013, VS 2015, VS 2017 or VS 2019 was installed with the Visual C++ option

error: could not compile `compiler_builtins` due to previous error
warning: build failed, waiting for other jobs to finish...
error: build failed
</code></pre>
<p>出现此错误的原因是我们缺少 MSVC C++，因此不满足<a href="https://github.com/rust-lang/cc-rs#compile-time-requirements">编译时要求</a>。请安装 <a href="https://rust-lang.github.io/rustup/installation/windows.html">Visual Studio 2013（或更高版本）或 Visual C++ Build Tools 2019</a>。对于 Visual Studio，确保选择了 “C++ tools” 和 “Windows 10 SDK” 选项。
如果使用 GNU ABI，请安装 <a href="https://www.msys2.org/">MinGW/MSYS2 工具链</a>。</p>
<h2 id="faq"><a class="header" href="#faq">FAQ</a></h2>
<h3 id="更新了-sdkconfigdefaults-文件但没有任何效果"><a class="header" href="#更新了-sdkconfigdefaults-文件但没有任何效果">更新了 <code>sdkconfig.defaults</code> 文件，但没有任何效果</a></h3>
<p>必须清理并重新构建项目，才能使 <code>sdkconfig.defaults</code> 中的修改生效：</p>
<pre><code class="language-shell">cargo clean
cargo build
</code></pre>
<h3 id="本页提到的-crate-的文档已过时或丢失"><a class="header" href="#本页提到的-crate-的文档已过时或丢失">本页提到的 crate 的文档已过时或丢失</a></h3>
<p>由于 <a href="https://docs.rs">docs.rs</a> 施加的<a href="https://docs.rs/about/builds#hitting-resource-limits">资源限制</a>，构建文档时不允许访问互联网。因此，我们无法构建 <code>esp-idf-sys</code> 或任何依赖于它的 crate 的文档。</p>
<p>作为替代，我们构建了文档，并将其托管在 GitHub Pages 上：</p>
<ul>
<li><a href="https://esp-rs.github.io/esp-idf-hal/esp_idf_hal/"><code>esp-idf-hal</code> 文档</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-svc/esp_idf_svc/"><code>esp-idf-svc</code> 文档</a></li>
<li><a href="https://esp-rs.github.io/esp-idf-sys/esp_idf_sys/"><code>esp-idf-sys</code> 文档</a></li>
</ul>
<h3 id="a-stack-overflow-in-task-main-has-been-detectedmain-任务栈溢出"><a class="header" href="#a-stack-overflow-in-task-main-has-been-detectedmain-任务栈溢出">A Stack Overflow in Task <code>main</code> has Been Detected（<code>main</code> 任务栈溢出）</a></h3>
<p>如果第二阶段 bootloader 报告了这个错误，你可能需要增加 main 任务的栈大小。可以通过将以下内容添加到 <code>sdkconfig.defaults</code> 文件来实现：</p>
<pre><code class="language-text">CONFIG_ESP_MAIN_TASK_STACK_SIZE=7000
</code></pre>
<p>在本例中，我们为 main 任务的栈分配了 7 kB。</p>
<h3 id="如何关闭看门狗定时器"><a class="header" href="#如何关闭看门狗定时器">如何关闭看门狗定时器？</a></h3>
<p>向 <code>sdkconfig.defaults</code> 文件添加：</p>
<pre><code class="language-text">CONFIG_INT_WDT=n
CONFIG_ESP_TASK_WDT=n
</code></pre>
<p>请记住，修改了这些配置文件后，必须在重新构建之前清理项目。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="assets/mermaid.min.js"></script>
        <script src="assets/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
